Go implementation for Flatdata
GDG Berlin Golang meetup
12 Mar 2018

Artem Nikitin
System Engineer, HERE Technologies
hi@artemnikitin.com
https://artemnikitin.com
@artemnikitin

* Why Flatdata?

Existed data format was optimized for embedded and client apps:

- Reduced space consumption (Disk)

- Incremental processing tile-by-tile (CPU)

Drawbacks for backend:

- Decoding tiles and reconstructing world representation (CPU Time)

- Custom tile cache not shared between service processes (RAM)

* Introducing Flatdata

What is Flatdata?

Flatdata is a library providing data structures for convenient creation, storage and access of packed memory-mappable structures with minimal overhead. 

Library consists of:

- Schema language

- Code generators for target languages

- Target language libraries

* When it's useful?

- Your data updates infrequently and accessed much more often than updated

- You can afford to recreate the full data archive every time 

- Your data fits in the RAM on target instance

- You want to optimize your data to be cache-friendly

* Example

.link https://github.com/artemnikitin/flatdata-go-coappearances-example

Schema 

    namespace coappearances {    

    struct Meta {    
        title_ref : u32 : 32;    
        author_ref : u32 : 32;   
    }       
     
    // And so on ...        

    archive Graph {     
        meta : Meta;    
        vertices : vector< Character >; 
        edges : vector< Coappearance >; 
        vertices_data : multivector< 32, Nickname, Description, UnaryRelation, BinaryRelation >; 
        chapters : vector< Chapter >;   
        strings : raw_data;  
    }   

    }        

* Example

Generate sources based on schema

	app.py -v -g go \
	-s coappearances.flatdata \
	-O coappearances/coappearances_generated.go

Generated Go code isn't properly Go formated!

* Example

Use generated sources

	log.SetFlags(log.LstdFlags | log.Lshortfile)
	
	cg, err := coappearances.OpenGraphArchive(flatdata.NewFileResourceStorage("flatdata/Graph.archive"))
	if err != nil {
		log.Fatal(err)
	}
	defer cg.Close()

	fmt.Println(cg.ToString())

